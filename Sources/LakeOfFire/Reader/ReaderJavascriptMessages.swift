import Foundation
import SwiftUIWebView
import RealmSwift

public struct NestedDOMRootSelector {
    public let layer0FrameSelector: String?
    public let layer1ShadowRootSelector: String?
    public let layer2ShadowRootSelector: String?
    
    public init?(layer0FrameSelector: String?, layer1ShadowRootSelector: String?, layer2ShadowRootSelector: String?) {
        guard layer1ShadowRootSelector != nil || layer0FrameSelector != nil else {
            return nil
        }
        self.layer0FrameSelector = layer0FrameSelector
        self.layer1ShadowRootSelector = layer1ShadowRootSelector
        self.layer2ShadowRootSelector = layer2ShadowRootSelector
    }
}

public struct ReaderModeUnavailableMessage {
    public let pageURL: URL?
    public let windowURL: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        pageURL = URL(string: body["pageURL"] as! String)
        windowURL = URL(string: body["windowURL"] as! String)
    }
}

public struct ReadabilityParsedMessage {
    public let pageURL: URL?
    public let windowURL: URL?
    public let readabilityContainerSelector: String?
    public let readabilityContainerRootSelector: NestedDOMRootSelector?
    public let title: String
    public let byline: String
    public let content: String
    public let inputHTML: String
    public let outputHTML: String
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        pageURL = URL(string: body["pageURL"] as! String)
        windowURL = URL(string: body["windowURL"] as! String)
        
        readabilityContainerSelector = body["readabilityContainerSelector"] as? String
        readabilityContainerRootSelector = NestedDOMRootSelector(
            layer0FrameSelector: body["layer0FrameSelector"] as? String,
            layer1ShadowRootSelector: body["layer1ShadowRootSelector"] as? String,
            layer2ShadowRootSelector: body["layer2ShadowRootSelector"] as? String)
        
        title = body["title"] as! String
        byline = body["byline"] as! String
        content = body["content"] as! String
        inputHTML = body["inputHTML"] as! String
        outputHTML = body["outputHTML"] as! String
    }
}

public struct VideoStatusMessage {
    public struct CaptionsOption {
        public let label: String
        public let languageCode: String
        public let kind: String
        public let isAutoGenerated: Bool
        public let baseURL: URL
        
        init?(dictionary: [String: Any]) {
            guard
                let label = dictionary["label"] as? String,
                let languageCode = dictionary["languageCode"] as? String,
                let kind = dictionary["kind"] as? String,
                let isAutoGenerated = dictionary["isAutoGenerated"] as? Bool,
                let baseURLString = dictionary["baseURL"] as? String,
                let baseURL = URL(string: baseURLString)
            else {
                print("Failed to decode CaptionsOption:", dictionary)
                return nil
            }
            
            self.label = label
            self.languageCode = languageCode
            self.kind = kind
            self.isAutoGenerated = isAutoGenerated
            self.baseURL = baseURL
        }
    }
    
    public let windowURL: URL?
    public let pageURL: URL?
    public let providerVideoID: String?
    public let captionsOptions: [CaptionsOption]
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        pageURL = URL(string: body["pageURL"] as! String)
        windowURL = URL(string: body["windowURL"] as! String)
        providerVideoID = body["providerVideoID"] as? String
        
        if let captionsArray = body["captionsOptions"] as? [[String: Any]] {
            captionsOptions = captionsArray.compactMap { CaptionsOption(dictionary: $0) }
        } else {
            print("No valid captionsOptions found.")
            captionsOptions = []
        }
    }
}

public struct PageMetadataUpdatedMessage {
    public let title: String
    public let author: String
    public let url: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any], let title = body["title"] as? String, let author = body["title"] as? String else { return nil }
        self.title = title
        self.author = author
        url = URL(string: body["url"] as! String)
    }
}

public struct ImageUpdatedMessage {
    public var newImageURL: URL? = nil
    public var mainDocumentURL: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        if let raw = body["newImageURL"] as? String, let url = URL(string: raw) {
            newImageURL = url
        }
        if let rawPage = body["mainDocumentURL"] as? String, let pageURL = URL(string: rawPage) {
            mainDocumentURL = pageURL
        }
    }
}

public struct WritingDirectionMessage {
    public var writingDirection: String
    public var mainDocumentURL: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        
        guard let direction = body["writingDirection"] as? String else { return nil }
        writingDirection = direction
        if let rawPage = body["mainDocumentURL"] as? String, let pageURL = URL(string: rawPage) {
            mainDocumentURL = pageURL
        }
    }
}

//public struct YoutubeCaptionsMessage {
//    public enum Status: String {
//        case idle = "idle"
//        case loading = "loading"
//        case available = "available"
//        case unavailable = "unavailable"
//    }
//    
////    public let rssURLs: [[String]]
//    
//    public init?(fromMessage message: WebViewMessage) {
//        guard let body = message.body as? [String: Any] else { return nil }
////        rssURLs = body["rssURLs"] as! [[String]]
//    }
//}

public struct FractionalCompletionMessage {
    public var fractionalCompletion: Float
    public var cfi: String
    public var mainDocumentURL: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any], let completion = body["fractionalCompletion"] as? Double, let cfi = body["cfi"] as? String else { return nil }
        fractionalCompletion = Float(completion)
        self.cfi = cfi
        if let rawPage = body["mainDocumentURL"] as? String, let pageURL = URL(string: rawPage) {
            mainDocumentURL = pageURL
        }
    }
}

public struct RSSURLsMessage {
    public let rssURLs: [[String]]
    public var windowURL: URL?
    
    public init?(fromMessage message: WebViewMessage) {
        guard let body = message.body as? [String: Any] else { return nil }
        rssURLs = body["rssURLs"] as? [[String]] ?? []
        if let windowURLRaw = body["windowURL"] as? String {
            windowURL = URL(string: windowURLRaw)
        }
    }
}
