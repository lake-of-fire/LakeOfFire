import Foundation
import SwiftUIWebView
import LakeOfFireCore
import LakeOfFireAdblock
//import WebKit

public struct YoutubeCaptionsUserScript {
    public static let userScript = WebViewUserScript(source: script, injectionTime: .atDocumentStart, forMainFrameOnly: false, in: .page, allowedDomains: Set(["youtube.com", "m.youtube.com", "www.youtube.com"]))
    
    static private let script = #"""
        (function() {
            'use strict';
        
            class YoutubeTranscriptError extends Error {
              constructor(message) {
                super(`[YoutubeTranscript] ${message}`);
              }
            }

            function retrieveVideoId(videoUrl) {
              const videoIdMatch = videoUrl.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i);
              if (videoIdMatch && videoIdMatch[1]) {
                return videoIdMatch[1];
              } else {
                throw new YoutubeTranscriptError("Impossible to retrieve YouTube video ID.");
              }
            }

            function extractCaptionsFromPlayerResponse(playerResponse) {
              if (!playerResponse || !playerResponse.captions) {
                console.error('No captions found in player response.');
                return [];
              }

              const captionTracks = playerResponse.captions.playerCaptionsTracklistRenderer.captionTracks;
              const captions = captionTracks.map(track => ({
                label: track.name.simpleText,
                languageCode: track.languageCode,
                kind: track.kind || 'standard',
                isAutoGenerated: track.kind === 'asr',
                baseURL: track.baseUrl
              }));

              return captions;
            }

            function parseTranscriptEndpoint(document) {
              const scripts = Array.from(document.getElementsByTagName('script'));
              const playerScript = scripts.find(script => script.textContent.includes('ytInitialPlayerResponse = '));
              if (!playerScript) throw new YoutubeTranscriptError("Player response not found.");

              const playerResponseMatch = playerScript.textContent.match(/ytInitialPlayerResponse\s*=\s*(\{.*?\});/s);
              if (!playerResponseMatch) throw new YoutubeTranscriptError("Failed to parse player response.");

              return JSON.parse(playerResponseMatch[1]);
            }

            function checkAndSendCaptions() {
                if (!["youtube.com", "m.youtube.com", "www.youtube.com"].includes(window.location.host)) {
                    return;
                }
        
              try {
                const playerResponseScript = Array.from(document.querySelectorAll('script')).find(script => script.textContent.includes('ytInitialPlayerResponse'));
                if (playerResponseScript) {
                  const playerResponse = parseTranscriptEndpoint(document);
                  const captions = extractCaptionsFromPlayerResponse(playerResponse);

                  const captionData = {
                    windowURL: window.top.location.href,
                    pageURL: document.location.href,
                    providerVideoID: new URL(location.href).searchParams.get('v'),
                    captionsOptions: captions,
                  };

                  if (window.webkit) {
                    window.webkit.messageHandlers.videoStatus.postMessage(captionData);
                  } else {
                    console.log(captionData);
                  }
                } else {
                  console.error('ytInitialPlayerResponse script not found. Retrying...');
                console.log(window.location.href);
                console.log(window.top.location.href);
                  setTimeout(checkAndSendCaptions, 500); // Retry after 500ms
                }
              } catch (error) {
                console.error(error);
              }
            }

            // Observe URL changes and call sendCaptions
            let lastUrl = location.href;
            new MutationObserver(() => {
              const currentUrl = location.href;
              if (currentUrl !== lastUrl) {
                lastUrl = currentUrl;
                checkAndSendCaptions();
              }
            }).observe(document, { subtree: true, childList: true });

            // Initial call
            checkAndSendCaptions();
        })();
        """#
}
